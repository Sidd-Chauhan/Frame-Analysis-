# -*- coding: utf-8 -*-
"""ASA_project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ciKViK6Xrv_ewmh7-vtY8qK8KUHmV-BM
"""

import pandas as pd
data=pd.ExcelFile("/content/Project_Data.xlsx")

data1=pd.read_excel(data,'Member')
data2=pd.read_excel(data,'Node')

data1

data2

member_data=data1.values     #convert dataframe into array and then manupulation can be done easily
node_data=data2.values

number_of_member=len(data1['Serial No.'])
number_of_member

number_of_node=len(data2['Serial No.'])
number_of_node

import numpy as np
F_g=np.zeros((3*number_of_node,1))    #returns a new array of given shape and type, with zeros.
F_fg=np.zeros((3*number_of_node,1))
K_g=np.zeros((3*number_of_node,3*number_of_node))
d_g=np.zeros((3*number_of_node,1))

print(F_g)
print(F_fg)
print(K_g)
type(F_g)

"""Flattening the matrix Fx,Fy, Mz and then insert into F_g"""

F_g=pd.DataFrame(node_data[:,3:6].flatten()).values    #convert dataframe into array and then manupulation can be done easily
d_g=pd.DataFrame(node_data[:,6:9].flatten()).values    # boundary condition u_x , V_y and thet_z
print(F_g)
print(d_g)

import math
Length_list=[]
Angle_list=[]
E_list=[]
A_list=[]
I_list=[]
for i in range(number_of_member):
  node1=int(member_data[i,1])
  node2=int(member_data[i,2])
  x1=node_data[node1-1,1]
  y1=node_data[node1-1,2]
  x2=node_data[node2-1,1]
  y2=node_data[node2-1,2]
  p=[x1,y1]
  q=[x2,y2]
  Length_list.append(math.dist(p,q))
  Angle_list.append(math.atan2(y2-y1,x2-x1)*(180/math.pi))
  E_list.append(member_data[i,3])
  A_list.append(member_data[i,4])
  I_list.append(member_data[i,5])
print(Length_list)
print(Angle_list)
print(E_list)
print(A_list)
print(I_list)

"""fixed end moment and vertical reactions for **POINT** load

Point load   # input file no need to mention b column
"""

point_load=[]
a1 = []  #distance from left node
b1 = []  # distance from right node
for i in range(number_of_member):
  point_load.append(float(member_data[i,6]))
  a1.append(float(member_data[i,7]))
  b1.append(float(Length_list[i]-member_data[i,7]))
print(point_load)
print(b1)
print(a1)
# print(type(a[0]))
# print(type(b[0]))
# print(type(point_load[0]))
# print(type(Length_list[0]))

# f_fl_p=np.zeros((6,number_of_member))
# for i in range(number_of_member):
#   V_b = -(point_load[i])*(b1[i]/Length_list[i] + (b1[i]**2)*(a1[i])/Length_list[i]**3 - (a1[i]**2)*(b1[i])/Length_list[i]**3 )
#   M_a = -(point_load[i])*(b1[i]**2)*(a1[i])/Length_list[i]**2
#   M_b = -(point_load[i])*(a1[i]**2)*(b1[i])/Length_list[i]**2
#   f_fl_p[:,i]=[0,-point_load[i]-V_b,M_a,0,V_b,-M_b]
# f_fl_p

f_fl_p=np.zeros((6,number_of_member))
for i in range(number_of_member):
  V_a = -(point_load[i])*(b1[i]/Length_list[i] + (b1[i]**2)*(a1[i])/Length_list[i]**3 - (a1[i]**2)*(b1[i])/Length_list[i]**3 )
  M_a = -(point_load[i])*(b1[i]**2)*(a1[i])/Length_list[i]**2
  M_b = -(point_load[i])*(a1[i]**2)*(b1[i])/Length_list[i]**2
  f_fl_p[:,i]=[0,V_a,M_a,0,-point_load[i]-V_a,-M_b]
f_fl_p

"""Fixed end moemnt and vertical reaction for distributed load"""

a=[]
b=[]
c=[]
d=[]
w1=[]
w2=[]
for i in range(number_of_member):
  w1.append(-member_data[i][8])
  w2.append(-member_data[i][9])
  a.append(member_data[i][10])
  b.append(member_data[i][11])
  c.append(member_data[i][12])
  d.append(member_data[i][13])
print(a,b,c,d,w1,w2)

Va=[]
ma=[]
for i in range(number_of_member):
  Va.append(((w1[i]*(b[i]-a[i])/2) + ((w2[i]-w1[i])*(c[i]-b[i])/2) + (w1[i]*(c[i]-b[i])) + (w2[i]*(d[i]-c[i])/2) ))    # upward direction
  ma.append(((w1[i]*(b[i]-a[i])/2)*(a[i]+2*b[i])/3 + ((w2[i]-w1[i])*(c[i]-b[i])/2)*((b[i]+2*c[i])/3) + (w1[i]*(c[i]-b[i]))*((b[i]+c[i])/2) + (w2[i]*(d[i]-c[i])/2)*((2*c[i]+d[i])/3)))   # anticlockwise
print(Va,ma)

import matplotlib.pyplot as plt
import numpy as np
import sympy as sy
import math



# from right  (L-d) < x < (L-c)
deflection_4=[]
slope_4=[]
for i in range(number_of_member):
  def f(x):
    M = -(w2[i]*(x-Length_list[i]+d[i])**3)/(6*(d[i]-c[i]))
    if (d[i]-c[i])==0 and w2[i]==0:
        M=0
    return M
  x = sy.Symbol("x")
  deflection_4.append(sy.integrate(f(x)*x, (x, Length_list[i]-d[i], Length_list[i]-c[i])))
  slope_4.append(sy.integrate(f(x), (x, Length_list[i]-d[i], Length_list[i]-c[i])))
print(deflection_4,slope_4)

# for 0 < x < a
deflection_1=[]
slope_1=[]
for i in range(number_of_member):
    def f(x):
      M= Va[i] * x - ma[i]
      return M
    x = sy.Symbol("x")
    deflection_1.append(sy.integrate(f(x)*(Length_list[i]-x), (x, 0, a[i])))
    slope_1.append(sy.integrate(f(x), (x, 0, a[i])))
print(deflection_1,slope_1)

# for a < x < b
deflection_2=[]
slope_2=[]
for i in range(number_of_member):
    def f(x):
      M = Va[i] * x - ma[i] - (w1[i]*(x-a[i])**3/(6*(b[i]-a[i])))
      if (b[i]-a[i])==0 :
        M = Va[i] * x - ma[i]
      return M
    x = sy.Symbol("x")
    deflection_2.append(sy.integrate(f(x)*(Length_list[i]-x), (x, a[i], b[i])))
    slope_2.append(sy.integrate(f(x), (x, a[i], b[i])))
print(deflection_2,slope_2)

# for b < x < c
deflection_3=[]
slope_3=[]
for i in range(number_of_member):
    def f(x):
      if abs(w2[i])>abs(w1[i]):
          M = Va[i] * x - ma[i] - ((w1[i]*(b[i]-a[i])/2))*(((b[i]-a[i])/3) + x - b[i]) - (w1[i]*((x-b[i])**2))/2 - (w1[i] + (((w2[i]-w1[i]))*(x-b[i])/(c[i]-b[i])))*((x-b[i])**2)/6
      elif w2==w1:
        M = Va[i] * x - ma[i] - ((w1[i]*(b[i]-a[i])/2))*(((b[i]-a[i])/3) + x - b[i]) - (w1[i]*((x-b[i])**2))/2
      else:
        M = Va[i] * x - ma[i] - ((w1[i]*(b[i]-a[i])/2))*(((b[i]-a[i])/3) + x - b[i]) - ((w1[i] + (((w2[i]-w1[i]))*(x-b[i])/(c[i]-b[i])))*((x-b[i])**2))/2 - (w1[i]-(w1[i] + (((w2[i]-w1[i]))*(x-b[i])/(c[i]-b[i]))))*((x-b[i])**2)/3
      if (c[i]-b[i])==0 :
        if abs(w2[i])>abs(w1[i]):
            M = Va[i] * x - ma[i] - ((w1[i]*(b[i]-a[i])/2))*(((b[i]-a[i])/3) + x - b[i]) - (w1[i]*((x-b[i])**2))/2
        elif w2==w1:
          M = Va[i] * x - ma[i] - ((w1[i]*(b[i]-a[i])/2))*(((b[i]-a[i])/3) + x - b[i]) - (w1[i]*((x-b[i])**2))/2
        else:
          M = Va[i] * x - ma[i] - ((w1[i]*(b[i]-a[i])/2))*(((b[i]-a[i])/3) + x - b[i])
      return M
    x = sy.Symbol("x")
    deflection_3.append(sy.integrate(f(x)*(Length_list[i]-x), (x, b[i], c[i])))
    slope_3.append(sy.integrate(f(x), (x, b[i], c[i])))
print(deflection_3,slope_3)

Total_deflection=[]
Total_slope=[]
for i in range(number_of_member):
    Total_deflection.append(deflection_1[i] + deflection_2[i] + deflection_3[i] + deflection_4[i])
    Total_slope.append(slope_1[i] + slope_2[i] + slope_3[i] + slope_4[i])
print(Total_deflection,Total_slope)

# A = np.array([[float(L**2/2) ,float(L**3/3)] , [float(L) , float(L**2/2)]])
# B = np.array([-Total_deflection,-Total_slope])
# # x=np.linalg.solve(A,B)
# # x
# print(A)
# C=np.linalg.inv(A)
# print(C)
# D=np.matmul(C,B)
# print(D)

# Total_deflection + (-Mb*L*L/2) + (Vb*L**3/3)     # Mb is in clockwise hence we should take it as negative
# Total_slope + (-Mb*L) + (Vb*L**2/2)
D=pd.DataFrame(np.zeros((2,number_of_member)))
for i in range(number_of_member):
  A=np.array([[float(Length_list[i]**2/2) ,float(Length_list[i]**3/3)] , [float(Length_list[i]) , float(Length_list[i]**2/2)]])
  B=np.array([-Total_deflection[i],-Total_slope[i]])
  D.loc[:,i]=np.matmul(np.linalg.inv(A),B)
print(D)

"""f_fl for distributed"""

# D[0,0] = Mb in anticlockwise  & D[1,0]= Vb in upward
f_fl_D=np.zeros((6,number_of_member))
for i in range(number_of_member):
  Vb_final=D.loc[1,i]
  Mb_final=D.loc[0,i]
  Va_final=Va[i]-Vb_final
  Ma_final=ma[i]-Vb_final*Length_list[i]-Mb_final
  f_fl_D[:,i]=[0,Va_final,Ma_final,0,Vb_final,Mb_final]
f_fl_D

"""F_fl_final"""

f_fl=np.zeros((6,number_of_member))
for i in range(number_of_member):
  f_fl[:,i]=np.array(f_fl_p[:,i])+np.array(f_fl_D[:,i])
f_fl

f_fl_D[:,1]+f_fl_D[:,0]

"""Adding transformation matrix"""

import math
def Tmatrix(A):           # A is in degree and it is transformation matrix
    Ar = A*(math.pi)/180
    cos = math.cos(Ar)
    sin = math.sin(Ar)
    matrix = np.array([[cos, -sin, 0, 0, 0, 0], [sin, cos, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0], [0, 0, 0, cos, -sin, 0], [0, 0, 0, sin, cos, 0], [0, 0, 0, 0, 0, 1]])
    # print(matrix)
    return matrix
Tmatrix(0)

Tmatrix(Angle_list[0])

"""Adding local stiffness matrix"""

def LSmatrix(A, E, I, L):
    FR = E*I
    a = (A*E)/L
    b = 12*FR/L**3
    c = 6*FR/L**2
    d = 4*FR/L
    eval = np.array([[a, 0, 0, -a, 0, 0], [0, b, c, 0, -b, c], [0, c, d, 0, -c, d/2], [-a, 0, 0, a, 0, 0], [0, -b, -c, 0, b, -c], [0, c, d/2, 0, -c, d]])
    return eval

# # K_l.loc[0:5,0:1]=f_fl             #adding matrix
# print(type(K_l))
# print(type(f_fl))
# print(type(LSmatrix(A_list[0],E_list[0],I_list[0],Length_list[0])))
# K_l

# K_l.loc[0:5,:] =

K_l = np.zeros((number_of_member*6,6))
K_l=pd.DataFrame(K_l)
for i in range(number_of_member):
  K_l.loc[6*i:6*(i+1)-1,:]=LSmatrix(A_list[i],E_list[i],I_list[i],Length_list[i])
K_l

K_g = np.zeros((number_of_member*6,6))
K_g=pd.DataFrame(K_g)
for i in range(number_of_member):
  K_g.loc[6*i:6*(i+1)-1,:]=np.matmul(Tmatrix(Angle_list[i]),np.matmul(LSmatrix(A_list[i],E_list[i],I_list[i],Length_list[i]),np.transpose(Tmatrix(Angle_list[i]))))
K_g

f_fg=np.zeros((6,number_of_member))
f_fg=pd.DataFrame(f_fg)
f_fl=pd.DataFrame(f_fl)
for i in range(number_of_member):
  f_fg.loc[:,i]=np.matmul(Tmatrix(Angle_list[i]),f_fl.loc[:,i])
f_fg

F_fg_final=np.zeros((3*number_of_node,1))
F_fg_final=pd.DataFrame(F_fg_final)
for i in range(number_of_member):
  F_fg_final.loc[3*i:3*i+5,0]=np.array(F_fg_final.loc[3*i:3*i+5,0])+np.array(f_fg.loc[:,i])
F_fg_final

print(K_g.loc[0,0]+K_g.loc[6,5])
type(K_g.loc[0,0]+K_g.loc[6,5])
f=f_fl.loc[:,0]+f_fl.loc[:,1]
# type(K_final_global)

K_final_global = np.zeros((3*number_of_node,3*number_of_node))
K_final_global=pd.DataFrame(K_final_global)
for i in range(number_of_member):
  K_final_global.loc[3*i:(3*i+5),3*i:(3*i+5)]=np.array(K_final_global.loc[3*i:(3*i+5),3*i:(3*i+5)])+np.array(K_g.loc[6*i:6*i+5,:])
K_final_global

Difference=np.subtract(F_g,F_fg_final)
Unknown_DOF=[]
for i in range(len(d_g)):
  if d_g[i][0]==1:
    Unknown_DOF.append(i)
Difference

length=len(Unknown_DOF)
dummy_stiffness_matrix = np.zeros((length,length))
dummy_force = np.zeros((length,1))
for i in range(length):
    for j in range(length):
      dummy_stiffness_matrix[i][j]=K_final_global.loc[Unknown_DOF[i],Unknown_DOF[j]]
for i in range(length):
  dummy_force[i][0]=Difference.loc[Unknown_DOF[i],0]
dummy_stiffness_matrix

inverse_dummy_k=np.linalg.inv(dummy_stiffness_matrix)
unknown_displacement=np.matmul(inverse_dummy_k,dummy_force)
unknown_displacement

displacement=np.zeros((3*number_of_node,1))
for i in range(length):
  displacement[Unknown_DOF[i]][0]=unknown_displacement[i][0]
displacement

force=F_fg_final+np.matmul(K_final_global,displacement)
print(force)